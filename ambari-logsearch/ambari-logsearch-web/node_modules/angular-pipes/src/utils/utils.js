"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isUndefined(value) {
    return typeof value === 'undefined';
}
exports.isUndefined = isUndefined;
function isNull(value) {
    return value === null;
}
exports.isNull = isNull;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
function isNumberFinite(value) {
    return isNumber(value) && isFinite(value);
}
exports.isNumberFinite = isNumberFinite;
// Not strict positive
function isPositive(value) {
    return value >= 0;
}
exports.isPositive = isPositive;
function isInteger(value) {
    // No rest, is an integer
    return (value % 1) === 0;
}
exports.isInteger = isInteger;
function isNil(value) {
    return value === null || typeof (value) === 'undefined';
}
exports.isNil = isNil;
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
function isObject(value) {
    return typeof value === 'object';
}
exports.isObject = isObject;
function isArray(value) {
    return Array.isArray(value);
}
exports.isArray = isArray;
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
function toDecimal(value, decimal) {
    return Math.round(value * Math.pow(10, decimal)) / Math.pow(10, decimal);
}
exports.toDecimal = toDecimal;
function upperFirst(value) {
    return value.slice(0, 1).toUpperCase() + value.slice(1);
}
exports.upperFirst = upperFirst;
function createRound(method) {
    // <any>Math to suppress error
    var func = Math[method];
    return function (value, precision) {
        if (precision === void 0) { precision = 0; }
        if (typeof value === 'string') {
            throw new TypeError('Rounding method needs a number');
        }
        if (typeof precision !== 'number' || isNaN(precision)) {
            precision = 0;
        }
        if (precision) {
            var pair = (value + "e").split('e');
            var val = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (val + "e").split('e');
            return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(value);
    };
}
exports.createRound = createRound;
function leftPad(str, len, ch) {
    if (len === void 0) { len = 0; }
    if (ch === void 0) { ch = ' '; }
    str = String(str);
    ch = toString(ch);
    var i = -1;
    var length = len - str.length;
    while (++i < length && (str.length + ch.length) <= len) {
        str = ch + str;
    }
    return str;
}
exports.leftPad = leftPad;
function rightPad(str, len, ch) {
    if (len === void 0) { len = 0; }
    if (ch === void 0) { ch = ' '; }
    str = String(str);
    ch = toString(ch);
    var i = -1;
    var length = len - str.length;
    while (++i < length && (str.length + ch.length) <= len) {
        str += ch;
    }
    return str;
}
exports.rightPad = rightPad;
function toString(value) {
    return "" + value;
}
exports.toString = toString;
function pad(str, len, ch) {
    if (len === void 0) { len = 0; }
    if (ch === void 0) { ch = ' '; }
    str = String(str);
    ch = toString(ch);
    var i = -1;
    var length = len - str.length;
    var left = true;
    while (++i < length) {
        var l = (str.length + ch.length <= len) ? (str.length + ch.length) : (str.length + 1);
        if (left) {
            str = leftPad(str, l, ch);
        }
        else {
            str = rightPad(str, l, ch);
        }
        left = !left;
    }
    return str;
}
exports.pad = pad;
function flatten(input, index) {
    if (index === void 0) { index = 0; }
    if (index >= input.length) {
        return input;
    }
    if (isArray(input[index])) {
        return flatten(input.slice(0, index).concat(input[index], input.slice(index + 1)), index);
    }
    return flatten(input, index + 1);
}
exports.flatten = flatten;
function getProperty(value, key) {
    if (isNil(value) || !isObject(value)) {
        return undefined;
    }
    var keys = key.split('.');
    var result = value[keys.shift()];
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key_1 = keys_1[_i];
        if (isNil(result) || !isObject(result)) {
            return undefined;
        }
        result = result[key_1];
    }
    return result;
}
exports.getProperty = getProperty;
function sum(input, initial) {
    if (initial === void 0) { initial = 0; }
    return input.reduce(function (previous, current) { return previous + current; }, initial);
}
exports.sum = sum;
// http://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array-in-javascript
function shuffle(input) {
    if (!isArray(input)) {
        return input;
    }
    var copy = input.slice();
    for (var i = copy.length; i; --i) {
        var j = Math.floor(Math.random() * i);
        var x = copy[i - 1];
        copy[i - 1] = copy[j];
        copy[j] = x;
    }
    return copy;
}
exports.shuffle = shuffle;
function deepIndexOf(collection, value) {
    var index = -1;
    var length = collection.length;
    while (++index < length) {
        if (deepEqual(value, collection[index])) {
            return index;
        }
    }
    return -1;
}
exports.deepIndexOf = deepIndexOf;
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (!(typeof a === 'object' && typeof b === 'object')) {
        return a === b;
    }
    var keysA = Object.keys(a);
    var keysB = Object.keys(b);
    if (keysA.length !== keysB.length) {
        return false;
    }
    // Test for A's keys different from B.
    var hasOwn = Object.prototype.hasOwnProperty;
    for (var i = 0; i < keysA.length; i++) {
        var key = keysA[i];
        if (!hasOwn.call(b, keysA[i]) || !deepEqual(a[key], b[key])) {
            return false;
        }
    }
    return true;
}
exports.deepEqual = deepEqual;
function isDeepObject(object) {
    return object.__isDeepObject__;
}
exports.isDeepObject = isDeepObject;
function wrapDeep(object) {
    return new DeepWrapper(object);
}
exports.wrapDeep = wrapDeep;
function unwrapDeep(object) {
    if (isDeepObject(object)) {
        return object.data;
    }
    return object;
}
exports.unwrapDeep = unwrapDeep;
var DeepWrapper = (function () {
    function DeepWrapper(data) {
        this.data = data;
        this.__isDeepObject__ = true;
    }
    return DeepWrapper;
}());
exports.DeepWrapper = DeepWrapper;
function count(input) {
    if (!isArray(input) && !isObject(input) && !isString(input)) {
        return input;
    }
    if (isObject(input)) {
        return Object.keys(input).map(function (value) { return input[value]; }).length;
    }
    return input.length;
}
exports.count = count;
function empty(input) {
    if (!isArray(input)) {
        return input;
    }
    return input.length === 0;
}
exports.empty = empty;
function every(input, predicate) {
    if (!isArray(input) || !predicate) {
        return input;
    }
    var result = true;
    var i = -1;
    while (++i < input.length && result) {
        result = predicate(input[i], i, input);
    }
    return result;
}
exports.every = every;
function takeUntil(input, predicate) {
    var i = -1;
    var result = [];
    while (++i < input.length && !predicate(input[i], i, input)) {
        result[i] = input[i];
    }
    return result;
}
exports.takeUntil = takeUntil;
function takeWhile(input, predicate) {
    return takeUntil(input, function (item, index, collection) { return !predicate(item, index, collection); });
}
exports.takeWhile = takeWhile;
//# sourceMappingURL=utils.js.map