"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var utils_1 = require("../utils/utils");
var OrderByPipe = (function () {
    function OrderByPipe() {
    }
    OrderByPipe._orderBy = function (a, b) {
        if (a instanceof Date && b instanceof Date) {
            return (a < b) ? -1 : (a > b) ? 1 : 0;
        }
        var floatA = parseFloat(a);
        var floatB = parseFloat(b);
        if (typeof a === 'string' && typeof b === 'string' && (isNaN(floatA) || isNaN(floatB))) {
            var lowerA = a.toLowerCase();
            var lowerB = b.toLowerCase();
            return (lowerA < lowerB) ? -1 : (lowerA > lowerB) ? 1 : 0;
        }
        return (floatA < floatB) ? -1 : (floatA > floatB) ? 1 : 0;
    };
    OrderByPipe.prototype.transform = function (input, config) {
        if (config === void 0) { config = '+'; }
        if (!utils_1.isArray(input)) {
            return input;
        }
        var configIsArray = utils_1.isArray(config);
        // If config === 'param' OR ['param'] 
        if (!configIsArray || (configIsArray && config.length === 1)) {
            var propertyToCheck = configIsArray ? config[0] : config;
            var first = propertyToCheck.substr(0, 1);
            var desc_1 = (first === '-'); // First character is '-'
            // Basic array (if only + or - is present)
            if (!propertyToCheck || propertyToCheck === '-' || propertyToCheck === '+') {
                return input.slice().sort(function (a, b) {
                    var comparator = OrderByPipe._orderBy(a, b);
                    return desc_1 ? -comparator : comparator;
                });
            }
            else {
                // If contains + or -, substring the property
                var property_1 = (first === '+' || desc_1) ? propertyToCheck.substr(1) : propertyToCheck;
                return input.slice().sort(function (a, b) {
                    var comparator = OrderByPipe._orderBy(a[property_1], b[property_1]);
                    return desc_1 ? -comparator : comparator;
                });
            }
        }
        else {
            return input.slice().sort(function (a, b) {
                for (var i = 0; i < config.length; ++i) {
                    var first = config[i].substr(0, 1);
                    var desc = (first === '-');
                    var property = (first === '+' || desc) ? config[i].substr(1) : config[i];
                    var comparator = OrderByPipe._orderBy(a[property], b[property]);
                    var comparison = desc ? -comparator : comparator;
                    if (comparison !== 0) {
                        return comparison;
                    }
                }
                return 0;
            });
        }
    };
    return OrderByPipe;
}());
OrderByPipe.decorators = [
    { type: core_1.Pipe, args: [{
                name: 'orderBy'
            },] },
];
/** @nocollapse */
OrderByPipe.ctorParameters = function () { return []; };
exports.OrderByPipe = OrderByPipe;
//# sourceMappingURL=order-by.pipe.js.map