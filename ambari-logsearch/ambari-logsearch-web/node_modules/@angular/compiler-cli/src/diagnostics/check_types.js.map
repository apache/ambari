{"version":3,"file":"check_types.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/diagnostics/check_types.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompiler, AotCompilerHost, AotCompilerOptions, EmitterVisitorContext, GeneratedFile, NgAnalyzedModules, ParseSourceSpan, Statement, StaticReflector, TypeScriptEmitter, createAotCompiler} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Diagnostic, DiagnosticCategory} from '../transformers/api';\n\ninterface FactoryInfo {\n  source: ts.SourceFile;\n  context: EmitterVisitorContext;\n}\n\ntype FactoryInfoMap = Map<string, FactoryInfo>;\n\nconst stubCancellationToken: ts.CancellationToken = {\n  isCancellationRequested(): boolean{return false;},\n  throwIfCancellationRequested(): void{}\n};\n\nexport class TypeChecker {\n  private _aotCompiler: AotCompiler|undefined;\n  private _reflector: StaticReflector|undefined;\n  private _factories: Map<string, FactoryInfo>|undefined;\n  private _factoryNames: string[]|undefined;\n  private _diagnosticProgram: ts.Program|undefined;\n  private _diagnosticsByFile: Map<string, Diagnostic[]>|undefined;\n  private _currentCancellationToken: ts.CancellationToken = stubCancellationToken;\n  private _partial: boolean = false;\n\n  constructor(\n      private program: ts.Program, private tsOptions: ts.CompilerOptions,\n      private compilerHost: ts.CompilerHost, private aotCompilerHost: AotCompilerHost,\n      private aotOptions: AotCompilerOptions, private _analyzedModules?: NgAnalyzedModules,\n      private _generatedFiles?: GeneratedFile[]) {}\n\n  getDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken): Diagnostic[] {\n    this._currentCancellationToken = cancellationToken || stubCancellationToken;\n    try {\n      return fileName ?\n          this.diagnosticsByFileName.get(fileName) || [] :\n          ([] as Diagnostic[]).concat(...Array.from(this.diagnosticsByFileName.values()));\n    } finally {\n      this._currentCancellationToken = stubCancellationToken;\n    }\n  }\n\n  get partialResults(): boolean { return this._partial; }\n\n  private get analyzedModules(): NgAnalyzedModules {\n    return this._analyzedModules || (this._analyzedModules = this.aotCompiler.analyzeModulesSync(\n                                         this.program.getSourceFiles().map(sf => sf.fileName)));\n  }\n\n  private get diagnosticsByFileName(): Map<string, Diagnostic[]> {\n    return this._diagnosticsByFile || this.createDiagnosticsByFile();\n  }\n\n  private get diagnosticProgram(): ts.Program {\n    return this._diagnosticProgram || this.createDiagnosticProgram();\n  }\n\n  private get generatedFiles(): GeneratedFile[] {\n    let result = this._generatedFiles;\n    if (!result) {\n      this._generatedFiles = result = this.aotCompiler.emitAllImpls(this.analyzedModules);\n    }\n    return result;\n  }\n\n  private get aotCompiler(): AotCompiler {\n    return this._aotCompiler || this.createCompilerAndReflector();\n  }\n\n  private get reflector(): StaticReflector {\n    let result = this._reflector;\n    if (!result) {\n      this.createCompilerAndReflector();\n      result = this._reflector !;\n    }\n    return result;\n  }\n\n  private get factories(): Map<string, FactoryInfo> {\n    return this._factories || this.createFactories();\n  }\n\n  private get factoryNames(): string[] {\n    return this._factoryNames || (this.createFactories() && this._factoryNames !);\n  }\n\n  private createCompilerAndReflector() {\n    const {compiler, reflector} = createAotCompiler(this.aotCompilerHost, this.aotOptions);\n    this._reflector = reflector;\n    return this._aotCompiler = compiler;\n  }\n\n  private createDiagnosticProgram() {\n    // Create a program that is all the files from the original program plus the factories.\n    const existingFiles = this.program.getSourceFiles().map(source => source.fileName);\n    const host = new TypeCheckingHost(this.compilerHost, this.program, this.factories);\n    return this._diagnosticProgram =\n               ts.createProgram([...existingFiles, ...this.factoryNames], this.tsOptions, host);\n  }\n\n  private createFactories() {\n    // Create all the factory files with enough information to map the diagnostics reported for the\n    // created file back to the original source.\n    const emitter = new TypeScriptEmitter();\n    const factorySources =\n        this.generatedFiles.filter(file => file.stmts != null && file.stmts.length)\n            .map<[string, FactoryInfo]>(\n                file => [file.genFileUrl, createFactoryInfo(emitter, file)]);\n    this._factories = new Map(factorySources);\n    this._factoryNames = Array.from(this._factories.keys());\n    return this._factories;\n  }\n\n  private createDiagnosticsByFile() {\n    // Collect all the diagnostics binned by original source file name.\n    const result = new Map<string, Diagnostic[]>();\n    const diagnosticsFor = (fileName: string) => {\n      let r = result.get(fileName);\n      if (!r) {\n        r = [];\n        result.set(fileName, r);\n      }\n      return r;\n    };\n    const program = this.diagnosticProgram;\n    for (const factoryName of this.factoryNames) {\n      if (this._currentCancellationToken.isCancellationRequested()) return result;\n      const sourceFile = program.getSourceFile(factoryName);\n      for (const diagnostic of this.diagnosticProgram.getSemanticDiagnostics(sourceFile)) {\n        const span = this.sourceSpanOf(diagnostic.file, diagnostic.start, diagnostic.length);\n        if (span) {\n          const fileName = span.start.file.url;\n          const diagnosticsList = diagnosticsFor(fileName);\n          diagnosticsList.push({\n            message: diagnosticMessageToString(diagnostic.messageText),\n            category: diagnosticCategoryConverter(diagnostic.category), span\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  private sourceSpanOf(source: ts.SourceFile, start: number, length: number): ParseSourceSpan|null {\n    // Find the corresponding TypeScript node\n    const info = this.factories.get(source.fileName);\n    if (info) {\n      const {line, character} = ts.getLineAndCharacterOfPosition(source, start);\n      return info.context.spanOf(line, character);\n    }\n    return null;\n  }\n}\n\nfunction diagnosticMessageToString(message: ts.DiagnosticMessageChain | string): string {\n  return ts.flattenDiagnosticMessageText(message, '\\n');\n}\n\nfunction diagnosticCategoryConverter(kind: ts.DiagnosticCategory) {\n  // The diagnostics kind matches ts.DiagnosticCategory. Review this code if this changes.\n  return kind as any as DiagnosticCategory;\n}\n\nfunction createFactoryInfo(emitter: TypeScriptEmitter, file: GeneratedFile): FactoryInfo {\n  const {sourceText, context} =\n      emitter.emitStatementsAndContext(file.srcFileUrl, file.genFileUrl, file.stmts !);\n  const source = ts.createSourceFile(\n      file.genFileUrl, sourceText, ts.ScriptTarget.Latest, /* setParentNodes */ true);\n  return {source, context};\n}\n\nclass TypeCheckingHost implements ts.CompilerHost {\n  constructor(\n      private host: ts.CompilerHost, private originalProgram: ts.Program,\n      private factories: Map<string, FactoryInfo>) {}\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)): ts.SourceFile {\n    const originalSource = this.originalProgram.getSourceFile(fileName);\n    if (originalSource) {\n      return originalSource;\n    }\n    const factoryInfo = this.factories.get(fileName);\n    if (factoryInfo) {\n      return factoryInfo.source;\n    }\n    return this.host.getSourceFile(fileName, languageVersion, onError);\n  }\n\n  getDefaultLibFileName(options: ts.CompilerOptions): string {\n    return this.host.getDefaultLibFileName(options);\n  }\n\n  writeFile: ts.WriteFileCallback =\n      () => { throw new Error('Unexpected write in diagnostic program'); };\n\n  getCurrentDirectory(): string { return this.host.getCurrentDirectory(); }\n\n  getDirectories(path: string): string[] { return this.host.getDirectories(path); }\n\n  getCanonicalFileName(fileName: string): string {\n    return this.host.getCanonicalFileName(fileName);\n  }\n\n  useCaseSensitiveFileNames(): boolean { return this.host.useCaseSensitiveFileNames(); }\n\n  getNewLine(): string { return this.host.getNewLine(); }\n\n  fileExists(fileName: string): boolean {\n    return this.factories.has(fileName) || this.host.fileExists(fileName);\n  }\n\n  readFile(fileName: string): string {\n    const factoryInfo = this.factories.get(fileName);\n    return (factoryInfo && factoryInfo.source.text) || this.host.readFile(fileName);\n  }\n}\n"]}