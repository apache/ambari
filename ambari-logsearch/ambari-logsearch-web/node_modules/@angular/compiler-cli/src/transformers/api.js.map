{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/api.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAKH,IAAY,kBAIX;AAJD,WAAY,kBAAkB;IAC5B,iEAAW,CAAA;IACX,6DAAS,CAAA;IACT,iEAAW,CAAA;AACb,CAAC,EAJW,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAI7B;AAoHD,IAAY,SASX;AATD,WAAY,SAAS;IACnB,uCAAY,CAAA;IACZ,qCAAW,CAAA;IACX,iDAAiB,CAAA;IACjB,qDAAmB,CAAA;IACnB,gDAAgB,CAAA;IAEhB,+CAAkB,CAAA;IAClB,wCAAgD,CAAA;AAClD,CAAC,EATW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QASpB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nexport enum DiagnosticCategory {\n  Warning = 0,\n  Error = 1,\n  Message = 2,\n}\n\nexport interface Diagnostic {\n  message: string;\n  span?: ParseSourceSpan;\n  category: DiagnosticCategory;\n}\n\nexport interface CompilerOptions extends ts.CompilerOptions {\n  // Absolute path to a directory where generated file structure is written.\n  // If unspecified, generated files will be written alongside sources.\n  genDir?: string;\n\n  // Path to the directory containing the tsconfig.json file.\n  basePath?: string;\n\n  // Don't produce .metadata.json files (they don't work for bundled emit with --out)\n  skipMetadataEmit?: boolean;\n\n  // Produce an error if the metadata written for a class would produce an error if used.\n  strictMetadataEmit?: boolean;\n\n  // Don't produce .ngfactory.ts or .ngstyle.ts files\n  skipTemplateCodegen?: boolean;\n\n  // Whether to generate a flat module index of the given name and the corresponding\n  // flat module metadata. This option is intended to be used when creating flat\n  // modules similar to how `@angular/core` and `@angular/common` are packaged.\n  // When this option is used the `package.json` for the library should refered to the\n  // generated flat module index instead of the library index file. When using this\n  // option only one .metadata.json file is produced that contains all the metadata\n  // necessary for symbols exported from the library index.\n  // In the generated .ngfactory.ts files flat module index is used to import symbols\n  // includes both the public API from the library index as well as shrowded internal\n  // symbols.\n  // By default the .ts file supplied in the `files` files field is assumed to be\n  // library index. If more than one is specified, uses `libraryIndex` to select the\n  // file to use. If more than on .ts file is supplied and no `libraryIndex` is supplied\n  // an error is produced.\n  // A flat module index .d.ts and .js will be created with the given `flatModuleOutFile`\n  // name in the same location as the library index .d.ts file is emitted.\n  // For example, if a library uses `public_api.ts` file as the library index of the\n  // module the `tsconfig.json` `files` field would be `[\"public_api.ts\"]`. The\n  // `flatModuleOutFile` options could then be set to, for example `\"index.js\"`, which\n  // produces `index.d.ts` and  `index.metadata.json` files. The library's\n  // `package.json`'s `module` field would be `\"index.js\"` and the `typings` field would\n  // be `\"index.d.ts\"`.\n  flatModuleOutFile?: string;\n\n  // Preferred module id to use for importing flat module. References generated by `ngc`\n  // will use this module name when importing symbols from the flat module. This is only\n  // meaningful when `flatModuleOutFile` is also supplied. It is otherwise ignored.\n  flatModuleId?: string;\n\n  // Whether to generate code for library code.\n  // If true, produce .ngfactory.ts and .ngstyle.ts files for .d.ts inputs.\n  // Default is true.\n  generateCodeForLibraries?: boolean;\n\n  // Insert JSDoc type annotations needed by Closure Compiler\n  annotateForClosureCompiler?: boolean;\n\n  // Modify how angular annotations are emitted to improve tree-shaking.\n  // Default is static fields.\n  // decorators: Leave the Decorators in-place. This makes compilation faster.\n  //             TypeScript will emit calls to the __decorate helper.\n  //             `--emitDecoratorMetadata` can be used for runtime reflection.\n  //             However, the resulting code will not properly tree-shake.\n  // static fields: Replace decorators with a static field in the class.\n  //                Allows advanced tree-shakers like Closure Compiler to remove\n  //                unused classes.\n  annotationsAs?: 'decorators'|'static fields';\n\n  // Print extra information while running the compiler\n  trace?: boolean;\n\n  // Whether to enable support for <template> and the template attribute (true by default)\n  enableLegacyTemplate?: boolean;\n\n  // Whether to remove blank text nodes from compiled templates. It is `true` by default\n  // in Angular 4 and will be re-visited post Angular 5.\n  preserveWhitespaces?: boolean;\n}\n\nexport interface ModuleFilenameResolver {\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e. `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n\n  /**\n   * Converts a file path to a module name that can be used as an `import.\n   * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n   *\n   * See ImportResolver.\n   */\n  fileNameToModuleName(importedFilePath: string, containingFilePath: string): string|null;\n\n  getNgCanonicalFileName(fileName: string): string;\n\n  assumeFileExists(fileName: string): void;\n}\n\nexport interface CompilerHost extends ts.CompilerHost, ModuleFilenameResolver {\n  /**\n   * Load a referenced resource either statically or asynchronously. If the host returns a\n   * `Promise<string>` it is assumed the user of the corresponding `Program` will call\n   * `loadNgStructureAsync()`. Returing  `Promise<string>` outside `loadNgStructureAsync()` will\n   * cause a diagnostics diagnostic error or an exception to be thrown.\n   *\n   * If `loadResource()` is not provided, `readFile()` will be called to load the resource.\n   */\n  readResource?(fileName: string): Promise<string>|string;\n}\n\nexport enum EmitFlags {\n  DTS = 1 << 0,\n  JS = 1 << 1,\n  Metadata = 1 << 2,\n  I18nBundle = 1 << 3,\n  Summary = 1 << 4,\n\n  Default = DTS | JS,\n  All = DTS | JS | Metadata | I18nBundle | Summary\n}\n\n// TODO(chuckj): Support CustomTransformers once we require TypeScript 2.3+\n// export interface CustomTransformers {\n//   beforeTs?: ts.TransformerFactory<ts.SourceFile>[];\n//   afterTs?: ts.TransformerFactory<ts.SourceFile>[];\n// }\n\nexport interface Program {\n  /**\n   * Retrieve the TypeScript program used to produce semantic diagnostics and emit the sources.\n   *\n   * Angular structural information is required to produce the program.\n   */\n  getTsProgram(): ts.Program;\n\n  /**\n   * Retreive options diagnostics for the TypeScript options used to create the program. This is\n   * faster than calling `getTsProgram().getOptionsDiagnostics()` since it does not need to\n   * collect Angular structural information to produce the errors.\n   */\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken): ts.Diagnostic[];\n\n  /**\n   * Retrieve options diagnostics for the Angular options used to create the program.\n   */\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): Diagnostic[];\n\n  /**\n   * Retrive the syntax diagnostics from TypeScript. This is faster than calling\n   * `getTsProgram().getSyntacticDiagnostics()` since it does not need to collect Angular structural\n   * information to produce the errors.\n   */\n  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ts.Diagnostic[];\n\n  /**\n   * Retrieve the diagnostics for the structure of an Angular application is correctly formed.\n   * This includes validating Angular annotations and the syntax of referenced and imbedded HTML\n   * and CSS.\n   *\n   * Note it is important to displaying TypeScript semantic diagnostics along with Angular\n   * structural diagnostics as an error in the program strucutre might cause errors detected in\n   * semantic analysis and a semantic error might cause errors in specifying the program structure.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): Diagnostic[];\n\n  /**\n   * Retreive the semantic diagnostics from TypeScript. This is equivilent to calling\n   * `getTsProgram().getSemanticDiagnostics()` directly and is included for completeness.\n   */\n  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ts.Diagnostic[];\n\n  /**\n   * Retrieve the Angular semantic diagnostics.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n      Diagnostic[];\n\n  /**\n   * Load Angular structural information asynchronously. If this method is not called then the\n   * Angular structural information, including referenced HTML and CSS files, are loaded\n   * synchronously. If the supplied Angular compiler host returns a promise from `loadResource()`\n   * will produce a diagnostic error message or, `getTsProgram()` or `emit` to throw.\n   */\n  loadNgStructureAsync(): Promise<void>;\n\n  /**\n   * Retrieve the lazy route references in the program.\n   *\n   * Angular structural information is required to produce these routes.\n   */\n  getLazyRoutes(cancellationToken?: ts.CancellationToken): {[route: string]: string};\n\n  /**\n   * Emit the files requested by emitFlags implied by the program.\n   *\n   * Angular structural information is required to emit files.\n   */\n  emit({// transformers,\n        emitFlags, cancellationToken}: {\n    emitFlags: EmitFlags,\n    // transformers?: CustomTransformers, // See TODO above\n    cancellationToken?: ts.CancellationToken,\n  }): void;\n}\n"]}