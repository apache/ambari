{"version":3,"file":"module_filename_resolver.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/module_filename_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {CompilerOptions, ModuleFilenameResolver} from './api';\n\nconst EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nconst DTS = /\\.d\\.ts$/;\nconst NODE_MODULES = '/node_modules/';\nconst IS_GENERATED = /\\.(ngfactory|ngstyle|ngsummary)$/;\nconst SHALLOW_IMPORT = /^((\\w|-)+|(@(\\w|-)+(\\/(\\w|-)+)+))$/;\n\nexport function createModuleFilenameResolver(\n    tsHost: ts.ModuleResolutionHost, options: CompilerOptions): ModuleFilenameResolver {\n  const host = createModuleFilenameResolverHost(tsHost);\n\n  return options.rootDirs && options.rootDirs.length > 0 ?\n      new MultipleRootDirModuleFilenameResolver(host, options) :\n      new SingleRootDirModuleFilenameResolver(host, options);\n}\n\nclass SingleRootDirModuleFilenameResolver implements ModuleFilenameResolver {\n  private isGenDirChildOfRootDir: boolean;\n  private basePath: string;\n  private genDir: string;\n  private moduleFileNames = new Map<string, string|null>();\n\n  constructor(private host: ModuleFilenameResolutionHost, private options: CompilerOptions) {\n    // normalize the path so that it never ends with '/'.\n    this.basePath = path.normalize(path.join(options.basePath !, '.')).replace(/\\\\/g, '/');\n    this.genDir = path.normalize(path.join(options.genDir !, '.')).replace(/\\\\/g, '/');\n\n    const genPath: string = path.relative(this.basePath, this.genDir);\n    this.isGenDirChildOfRootDir = genPath === '' || !genPath.startsWith('..');\n  }\n\n  moduleNameToFileName(m: string, containingFile: string): string|null {\n    const key = m + ':' + (containingFile || '');\n    let result: string|null = this.moduleFileNames.get(key) || null;\n    if (!result) {\n      if (!containingFile) {\n        if (m.indexOf('.') === 0) {\n          throw new Error('Resolution of relative paths requires a containing file.');\n        }\n        // Any containing file gives the same result for absolute imports\n        containingFile = this.getNgCanonicalFileName(path.join(this.basePath, 'index.ts'));\n      }\n      m = m.replace(EXT, '');\n      const resolved =\n          ts.resolveModuleName(m, containingFile.replace(/\\\\/g, '/'), this.options, this.host)\n              .resolvedModule;\n      result = resolved ? this.getNgCanonicalFileName(resolved.resolvedFileName) : null;\n      this.moduleFileNames.set(key, result);\n    }\n    return result;\n  }\n\n  /**\n   * We want a moduleId that will appear in import statements in the generated code.\n   * These need to be in a form that system.js can load, so absolute file paths don't work.\n   *\n   * The `containingFile` is always in the `genDir`, where as the `importedFile` can be in\n   * `genDir`, `node_module` or `basePath`.  The `importedFile` is either a generated file or\n   * existing file.\n   *\n   *               | genDir   | node_module |  rootDir\n   * --------------+----------+-------------+----------\n   * generated     | relative |   relative  |   n/a\n   * existing file |   n/a    |   absolute  |  relative(*)\n   *\n   * NOTE: (*) the relative path is computed depending on `isGenDirChildOfRootDir`.\n   */\n  fileNameToModuleName(importedFile: string, containingFile: string): string {\n    // If a file does not yet exist (because we compile it later), we still need to\n    // assume it exists it so that the `resolve` method works!\n    if (!this.host.fileExists(importedFile)) {\n      this.host.assumeFileExists(importedFile);\n    }\n\n    containingFile = this.rewriteGenDirPath(containingFile);\n    const containingDir = path.dirname(containingFile);\n    // drop extension\n    importedFile = importedFile.replace(EXT, '');\n\n    const nodeModulesIndex = importedFile.indexOf(NODE_MODULES);\n    const importModule = nodeModulesIndex === -1 ?\n        null :\n        importedFile.substring(nodeModulesIndex + NODE_MODULES.length);\n    const isGeneratedFile = IS_GENERATED.test(importedFile);\n\n    if (isGeneratedFile) {\n      // rewrite to genDir path\n      if (importModule) {\n        // it is generated, therefore we do a relative path to the factory\n        return this.dotRelative(containingDir, this.genDir + NODE_MODULES + importModule);\n      } else {\n        // assume that import is also in `genDir`\n        importedFile = this.rewriteGenDirPath(importedFile);\n        return this.dotRelative(containingDir, importedFile);\n      }\n    } else {\n      // user code import\n      if (importModule) {\n        return importModule;\n      } else {\n        if (!this.isGenDirChildOfRootDir) {\n          // assume that they are on top of each other.\n          importedFile = importedFile.replace(this.basePath, this.genDir);\n        }\n        if (SHALLOW_IMPORT.test(importedFile)) {\n          return importedFile;\n        }\n        return this.dotRelative(containingDir, importedFile);\n      }\n    }\n  }\n\n  // We use absolute paths on disk as canonical.\n  getNgCanonicalFileName(fileName: string): string { return fileName; }\n\n  assumeFileExists(fileName: string) { this.host.assumeFileExists(fileName); }\n\n  private dotRelative(from: string, to: string): string {\n    const rPath: string = path.relative(from, to).replace(/\\\\/g, '/');\n    return rPath.startsWith('.') ? rPath : './' + rPath;\n  }\n\n  /**\n   * Moves the path into `genDir` folder while preserving the `node_modules` directory.\n   */\n  private rewriteGenDirPath(filepath: string) {\n    const nodeModulesIndex = filepath.indexOf(NODE_MODULES);\n    if (nodeModulesIndex !== -1) {\n      // If we are in node_module, transplant them into `genDir`.\n      return path.join(this.genDir, filepath.substring(nodeModulesIndex));\n    } else {\n      // pretend that containing file is on top of the `genDir` to normalize the paths.\n      // we apply the `genDir` => `rootDir` delta through `rootDirPrefix` later.\n      return filepath.replace(this.basePath, this.genDir);\n    }\n  }\n}\n\n/**\n * This version of the AotCompilerHost expects that the program will be compiled\n * and executed with a \"path mapped\" directory structure, where generated files\n * are in a parallel tree with the sources, and imported using a `./` relative\n * import. This requires using TS `rootDirs` option and also teaching the module\n * loader what to do.\n */\nclass MultipleRootDirModuleFilenameResolver implements ModuleFilenameResolver {\n  private basePath: string;\n\n  constructor(private host: ModuleFilenameResolutionHost, private options: CompilerOptions) {\n    // normalize the path so that it never ends with '/'.\n    this.basePath = path.normalize(path.join(options.basePath !, '.')).replace(/\\\\/g, '/');\n  }\n\n  getNgCanonicalFileName(fileName: string): string {\n    if (!fileName) return fileName;\n    // NB: the rootDirs should have been sorted longest-first\n    for (const dir of this.options.rootDirs || []) {\n      if (fileName.indexOf(dir) === 0) {\n        fileName = fileName.substring(dir.length);\n      }\n    }\n    return fileName;\n  }\n\n  assumeFileExists(fileName: string) { this.host.assumeFileExists(fileName); }\n\n  moduleNameToFileName(m: string, containingFile: string): string|null {\n    if (!containingFile) {\n      if (m.indexOf('.') === 0) {\n        throw new Error('Resolution of relative paths requires a containing file.');\n      }\n      // Any containing file gives the same result for absolute imports\n      containingFile = this.getNgCanonicalFileName(path.join(this.basePath, 'index.ts'));\n    }\n    for (const root of this.options.rootDirs || ['']) {\n      const rootedContainingFile = path.join(root, containingFile);\n      const resolved =\n          ts.resolveModuleName(m, rootedContainingFile, this.options, this.host).resolvedModule;\n      if (resolved) {\n        if (this.options.traceResolution) {\n          console.error('resolve', m, containingFile, '=>', resolved.resolvedFileName);\n        }\n        return this.getNgCanonicalFileName(resolved.resolvedFileName);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * We want a moduleId that will appear in import statements in the generated code.\n   * These need to be in a form that system.js can load, so absolute file paths don't work.\n   * Relativize the paths by checking candidate prefixes of the absolute path, to see if\n   * they are resolvable by the moduleResolution strategy from the CompilerHost.\n   */\n  fileNameToModuleName(importedFile: string, containingFile: string): string {\n    if (this.options.traceResolution) {\n      console.error(\n          'getImportPath from containingFile', containingFile, 'to importedFile', importedFile);\n    }\n\n    // If a file does not yet exist (because we compile it later), we still need to\n    // assume it exists so that the `resolve` method works!\n    if (!this.host.fileExists(importedFile)) {\n      if (this.options.rootDirs && this.options.rootDirs.length > 0) {\n        this.host.assumeFileExists(path.join(this.options.rootDirs[0], importedFile));\n      } else {\n        this.host.assumeFileExists(importedFile);\n      }\n    }\n\n    const resolvable = (candidate: string) => {\n      const resolved = this.moduleNameToFileName(candidate, importedFile);\n      return resolved && resolved.replace(EXT, '') === importedFile.replace(EXT, '');\n    };\n\n    const importModuleName = importedFile.replace(EXT, '');\n    const parts = importModuleName.split(path.sep).filter(p => !!p);\n    let foundRelativeImport: string|undefined;\n\n    for (let index = parts.length - 1; index >= 0; index--) {\n      let candidate = parts.slice(index, parts.length).join(path.sep);\n      if (resolvable(candidate)) {\n        return candidate;\n      }\n      candidate = '.' + path.sep + candidate;\n      if (resolvable(candidate)) {\n        foundRelativeImport = candidate;\n      }\n    }\n\n    if (foundRelativeImport) return foundRelativeImport;\n\n    // Try a relative import\n    const candidate = path.relative(path.dirname(containingFile), importModuleName);\n    if (resolvable(candidate)) {\n      return candidate;\n    }\n\n    throw new Error(\n        `Unable to find any resolvable import for ${importedFile} relative to ${containingFile}`);\n  }\n}\n\ninterface ModuleFilenameResolutionHost extends ts.ModuleResolutionHost {\n  assumeFileExists(fileName: string): void;\n}\n\nfunction createModuleFilenameResolverHost(host: ts.ModuleResolutionHost):\n    ModuleFilenameResolutionHost {\n  const assumedExists = new Set<string>();\n  const resolveModuleNameHost = Object.create(host);\n  // When calling ts.resolveModuleName, additional allow checks for .d.ts files to be done based on\n  // checks for .ngsummary.json files, so that our codegen depends on fewer inputs and requires\n  // to be called less often.\n  // This is needed as we use ts.resolveModuleName in reflector_host and it should be able to\n  // resolve summary file names.\n  resolveModuleNameHost.fileExists = (fileName: string): boolean => {\n    if (assumedExists.has(fileName)) {\n      return true;\n    }\n\n    if (host.fileExists(fileName)) {\n      return true;\n    }\n\n    if (DTS.test(fileName)) {\n      const base = fileName.substring(0, fileName.length - 5);\n      return host.fileExists(base + '.ngsummary.json');\n    }\n\n    return false;\n  };\n\n  resolveModuleNameHost.assumeFileExists = (fileName: string) => assumedExists.add(fileName);\n  // Make sure we do not `host.realpath()` from TS as we do not want to resolve symlinks.\n  // https://github.com/Microsoft/TypeScript/issues/9552\n  resolveModuleNameHost.realpath = (fileName: string) => fileName;\n\n  return resolveModuleNameHost;\n}\n"]}