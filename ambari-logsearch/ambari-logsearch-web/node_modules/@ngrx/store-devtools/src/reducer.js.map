{"version":3,"sources":["../../src/reducer.ts"],"names":[],"mappings":"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","file":"reducer.js","sourceRoot":"","sourcesContent":["import { Action, Dispatcher, Reducer } from '@ngrx/store';\n\nimport { difference, liftAction } from './utils';\nimport { ActionTypes } from './actions';\n\n\nexport const INIT_ACTION = { type: Dispatcher.INIT };\n\nexport interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: { [id: number]: { action: Action } };\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: { state: any, error: any }[];\n}\n\n/**\n* Computes the next entry in the log by applying an action.\n*/\nfunction computeNextEntry(reducer, action, state, error) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    console.error(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n\n/**\n* Runs the reducer on invalidated actions to get a fresh computation log.\n*/\nfunction recomputeStates(\n  computedStates,\n  minInvalidatedStateIndex,\n  reducer,\n  committedState,\n  actionsById,\n  stagedActionIds,\n  skippedActionIds\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    minInvalidatedStateIndex >= computedStates.length &&\n    computedStates.length === stagedActionIds.length\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry = shouldSkip ?\n      previousEntry :\n      computeNextEntry(reducer, action, previousState, previousError);\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n\nexport function liftInitialState(initialCommittedState?: any, monitorReducer?: any): LiftedState {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: []\n  };\n}\n\n/**\n* Creates a history state reducer from an app's reducer.\n*/\nexport function liftReducerWith(\n  initialCommittedState: any,\n  initialLiftedState: LiftedState,\n  monitorReducer?: any,\n  options: { maxAge?: number } = {}\n) {\n  /**\n  * Manages how the history actions modify the history state.\n  */\n  return reducer => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess\n        ? currentStateIndex - excess\n        : 0;\n    }\n\n    // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    switch (liftedAction.type) {\n      case ActionTypes.RESET: {\n        // Get back to the state the store was created with.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = initialCommittedState;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case ActionTypes.COMMIT: {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case ActionTypes.ROLLBACK: {\n        // Forget about any staged actions.\n        // Start again from the last committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case ActionTypes.TOGGLE_ACTION: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { id: actionId } = liftedAction;\n        const index = skippedActionIds.indexOf(actionId);\n        if (index === -1) {\n          skippedActionIds = [actionId, ...skippedActionIds];\n        } else {\n          skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n        }\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n        break;\n      }\n      case ActionTypes.SET_ACTIONS_ACTIVE: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { start, end, active } = liftedAction;\n        const actionIds = [];\n        for (let i = start; i < end; i++) actionIds.push(i);\n        if (active) {\n          skippedActionIds = difference(skippedActionIds, actionIds);\n        } else {\n          skippedActionIds = [...skippedActionIds, ...actionIds];\n        }\n\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n        break;\n      }\n      case ActionTypes.JUMP_TO_STATE: {\n        // Without recomputing anything, move the pointer that tell us\n        // which state is considered the current one. Useful for sliders.\n        currentStateIndex = liftedAction.index;\n        // Optimization: we know the history has not changed.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case ActionTypes.SWEEP: {\n        // Forget any actions that are currently being skipped.\n        stagedActionIds = difference(stagedActionIds, skippedActionIds);\n        skippedActionIds = [];\n        currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n        break;\n      }\n      case ActionTypes.PERFORM_ACTION: {\n        // Auto-commit as new actions come in.\n        if (options.maxAge && stagedActionIds.length === options.maxAge) {\n          commitExcessActions(1);\n        }\n\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        const actionId = nextActionId++;\n        // Mutation! This is the hottest path, and we optimize on purpose.\n        // It is safe because we set a new key in a cache dictionary.\n        actionsById[actionId] = liftedAction;\n        stagedActionIds = [...stagedActionIds, actionId];\n        // Optimization: we know that only the new action needs computing.\n        minInvalidatedStateIndex = stagedActionIds.length - 1;\n        break;\n      }\n      case ActionTypes.IMPORT_STATE: {\n        // Completely replace everything.\n        ({\n          monitorState,\n          actionsById,\n          nextActionId,\n          stagedActionIds,\n          skippedActionIds,\n          committedState,\n          currentStateIndex,\n          computedStates\n        } = liftedAction.nextLiftedState);\n        break;\n      }\n      case Reducer.REPLACE:\n      case Dispatcher.INIT: {\n        // Always recompute states on hot reload and init.\n        minInvalidatedStateIndex = 0;\n\n        if (options.maxAge && stagedActionIds.length > options.maxAge) {\n          // States must be recomputed before committing excess.\n          computedStates = recomputeStates(\n            computedStates,\n            minInvalidatedStateIndex,\n            reducer,\n            committedState,\n            actionsById,\n            stagedActionIds,\n            skippedActionIds\n          );\n\n          commitExcessActions(stagedActionIds.length - options.maxAge);\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      default: {\n        // If the action is not recognized, it's a monitor action.\n        // Optimization: a monitor action can't change history.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds\n    );\n    monitorState = monitorReducer(monitorState, liftedAction);\n\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates\n    };\n  };\n}\n"]}